<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>VIX100 — 3-Wave Momentum + Confirm Candle (All-in-one)</title>
<style>
  :root{
    --bg:#071025; --card:#0b1530; --muted:#9fb0d6; --accent:#2b8cf0;
    --green:#7ef2a4; --red:#ff9b9b; --mono: "Courier New",monospace;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#031028 0%, #071025 100%);color:#dcecff;font-family:Inter,system-ui,Arial,sans-serif}
  .wrap{max-width:1100px;margin:20px auto;padding:16px}
  .card{background:var(--card);border-radius:12px;padding:14px;margin-bottom:14px;box-shadow:0 8px 30px rgba(0,0,0,.6)}
  h1{margin:0 0 6px;font-size:20px}
  .muted{color:var(--muted);font-size:13px}
  label{display:block;margin-top:10px;font-size:13px;color:var(--muted)}
  input,select,button{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,.04);background:#061226;color:#eaf4ff;font-size:14px}
  .row{display:flex;gap:12px;flex-wrap:wrap}
  .col{flex:1;min-width:260px}
  .small{font-size:13px;color:var(--muted)}
  #ticks, #log{height:210px;overflow:auto;padding:8px;background:#041427;border-radius:8px;border:1px solid rgba(255,255,255,.03);font-family:var(--mono);font-size:13px}
  .statGrid{display:flex;gap:12px;align-items:center}
  .stat{padding:10px;border-radius:8px;background:rgba(255,255,255,.02);min-width:85px;text-align:center}
  .stat .n{font-weight:700;font-size:18px}
  .green{color:var(--green)} .red{color:var(--red)}
  button.primary{background:var(--accent);border:1px solid rgba(0,0,0,.2);color:white}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  footer{font-size:12px;color:var(--muted);text-align:center;margin-top:6px}
  .note{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>VIX100 — 3-Wave Momentum + Confirm Candle</h1>
    <div class="muted">Simple momentum strategy: detect strong direction from last <strong>30 ticks</strong>, require last <strong>3 ticks</strong> to confirm. Trade 1m (configurable). Use Demo mode first.</div>
  </div>

  <div class="card row">
    <div class="col">
      <label>Mode</label>
      <select id="mode">
        <option value="demo">Demo (simulate)</option>
        <option value="real">Real (requires API token)</option>
      </select>

      <label>Deriv API Token (Real only)</label>
      <input id="token" placeholder="Paste token here (only for Real mode)" />

      <label>Symbol</label>
      <input id="symbol" value="R_100" />

      <label>Stake (currency)</label>
      <input id="stake" type="number" value="1" min="0.01" step="0.01" />

      <label>Martingale multiplier</label>
      <input id="martingale" type="number" value="2.1" step="0.01" />

      <label>Trade duration (seconds)</label>
      <input id="duration" type="number" value="60" min="10" />

      <label>Momentum threshold (ups - downs ≥)</label>
      <input id="threshold" type="number" value="6" min="1" />

      <label>Confirmation ticks (last N must agree)</label>
      <input id="confirmN" type="number" value="3" min="1" max="10" />

      <label>Stop loss (session P/L)</label>
      <input id="stopLoss" type="number" value="-20" />

      <label>Take profit (session P/L)</label>
      <input id="takeProfit" type="number" value="30" />

      <div style="margin-top:12px" class="controls">
        <button id="startBtn" class="primary">Connect & Start</button>
        <button id="stopBtn">Stop</button>
        <button id="resetBtn">Reset Session</button>
      </div>

      <div style="margin-top:8px" class="note">Recommended: <strong>Demo</strong> first. Real mode requires token and carries financial risk.</div>
    </div>

    <div class="col">
      <label>Session stats</label>
      <div class="statGrid">
        <div class="stat"><div class="small">Trades</div><div id="trades" class="n">0</div></div>
        <div class="stat"><div class="small">Wins</div><div id="wins" class="n green">0</div></div>
        <div class="stat"><div class="small">Losses</div><div id="losses" class="n red">0</div></div>
        <div class="stat"><div class="small">P/L</div><div id="pl" class="n">0.00</div></div>
      </div>

      <label>Last 30 ticks (oldest → newest)</label>
      <div id="ticks"></div>
    </div>
  </div>

  <div class="card">
    <div class="row">
      <div class="col">
        <label>Strategy log</label>
        <div id="log"></div>
      </div>
      <div class="col">
        <label>Active config / notes</label>
        <div class="muted" style="line-height:1.5">
          <strong>Strategy</strong>: Collect 30 ticks → if (ups - downs) ≥ <span id="ui_threshold">6</span> → strong up momentum; if (downs - ups) ≥ <span id="ui_threshold">6</span> → strong down momentum. Require last <span id="ui_confirmN">3</span> ticks to match direction. Then place CALL/PUT for configured duration. Martingale applies on loss.
          <hr />
          Demo payout assumption: <strong>~80% payout when win</strong> (used only for Demo mode).
        </div>
      </div>
    </div>
  </div>

  <footer>Built for testing & learning — always demo before real funds.</footer>
</div>

<script>
(() => {
  // UI
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const resetBtn = document.getElementById('resetBtn');
  const modeSel = document.getElementById('mode');
  const tokenInput = document.getElementById('token');
  const symbolInput = document.getElementById('symbol');
  const stakeInput = document.getElementById('stake');
  const martingaleInput = document.getElementById('martingale');
  const durationInput = document.getElementById('duration');
  const thresholdInput = document.getElementById('threshold');
  const confirmNInput = document.getElementById('confirmN');
  const stopLossInput = document.getElementById('stopLoss');
  const takeProfitInput = document.getElementById('takeProfit');

  const ticksDiv = document.getElementById('ticks');
  const logDiv = document.getElementById('log');
  const tradesEl = document.getElementById('trades');
  const winsEl = document.getElementById('wins');
  const lossesEl = document.getElementById('losses');
  const plEl = document.getElementById('pl');
  const ui_threshold = document.getElementById('ui_threshold');
  const ui_confirmN = document.getElementById('ui_confirmN');

  // state
  let ws = null;
  let running = false;
  let ticks = []; // { epoch, quote }
  const TICK_WINDOW = 30;
  let session = { trades:0, wins:0, losses:0, pl:0 };
  let baseStake = parseFloat(stakeInput.value) || 1;
  let currentStake = baseStake;
  const APP_ID = 1089; // public app id
  let pendingSimTrades = []; // keep references for demo trades

  // UI dynamic reflect
  thresholdInput.addEventListener('input', () => ui_threshold.textContent = thresholdInput.value);
  confirmNInput.addEventListener('input', () => ui_confirmN.textContent = confirmNInput.value);

  function log(msg, cls='') {
    const t = new Date().toLocaleTimeString();
    const div = document.createElement('div');
    div.innerHTML = `<span style="color:#9fb0d6">[${t}]</span> ${msg}`;
    if (cls) div.classList.add(cls);
    logDiv.appendChild(div);
    logDiv.scrollTop = logDiv.scrollHeight;
  }

  function pushTick(quote, epoch) {
    ticks.push({ quote: Number(quote), epoch: Number(epoch) });
    if (ticks.length > TICK_WINDOW) ticks.shift();
    renderTicks();
  }

  function renderTicks() {
    ticksDiv.innerHTML = ticks.map(t => `${new Date(t.epoch*1000).toLocaleTimeString()} — ${t.quote.toFixed(2)}`).join('\n');
  }

  function resetSession() {
    session = { trades:0, wins:0, losses:0, pl:0 };
    baseStake = parseFloat(stakeInput.value) || 1;
    currentStake = baseStake;
    pendingSimTrades = [];
    updateStatsUI();
    log('Session reset.');
  }

  function updateStatsUI() {
    tradesEl.textContent = session.trades;
    winsEl.textContent = session.wins;
    lossesEl.textContent = session.losses;
    plEl.textContent = session.pl.toFixed(2);
    plEl.style.color = session.pl >= 0 ? '#7ef2a4' : '#ff9b9b';
  }

  // Evaluate strategy when we have at least TICK_WINDOW ticks
  function evaluateStrategy() {
    if (ticks.length < TICK_WINDOW) return;

    // compute ups/downs
    let ups = 0, downs = 0;
    for (let i=1;i<ticks.length;i++) {
      const d = ticks[i].quote - ticks[i-1].quote;
      if (d > 0) ups++;
      else if (d < 0) downs++;
    }
    const threshold = parseInt(thresholdInput.value,10) || 6;
    const confirmN = parseInt(confirmNInput.value,10) || 3;
    const lastN = ticks.slice(-confirmN);
    const lastN_direction = lastN.every((t,i) => {
      if (i===0) return true;
      return t.quote > lastN[i-1].quote;
    }) ? 'up' : (lastN.every((t,i) => { if (i===0) return true; return t.quote < lastN[i-1].quote; }) ? 'down' : 'mixed');

    log(`Momentum check — ups:${ups} downs:${downs} — last${confirmN}:${lastN_direction}`);

    // decide
    if ((ups - downs) >= threshold && lastN_direction === 'up') {
      // signal CALL
      triggerTrade('CALL');
    } else if ((downs - ups) >= threshold && lastN_direction === 'down') {
      triggerTrade('PUT');
    } else {
      // no signal
    }
  }

  // Trigger trade (demo or real)
  function triggerTrade(contractType) {
    // check SL/TP
    const stopLoss = Number(stopLossInput.value);
    const takeProfit = Number(takeProfitInput.value);
    if (!isNaN(stopLoss) && session.pl <= stopLoss) {
      log(`Stop loss reached (${session.pl.toFixed(2)} <= ${stopLoss}). Stopping.`, 'red');
      stop();
      return;
    }
    if (!isNaN(takeProfit) && session.pl >= takeProfit) {
      log(`Take profit reached (${session.pl.toFixed(2)} >= ${takeProfit}). Stopping.`, 'green');
      stop();
      return;
    }

    const stake = Number(currentStake.toFixed(2));
    const duration = Math.max(10, parseInt(durationInput.value,10) || 60);
    const entryPrice = ticks.length ? ticks[ticks.length-1].quote : null;
    const symbol = symbolInput.value || 'R_100';
    const mode = modeSel.value;

    const trade = {
      id: 't'+Date.now(),
      type: contractType,
      stake,
      duration,
      entryPrice,
      symbol,
      placedAt: Date.now(),
      status: 'pending',
      pnl: 0
    };

    log(`Signal => ${contractType} | stake ${stake} | dur ${duration}s | entry ${entryPrice !== null ? entryPrice.toFixed(2) : 'N/A'}`);

    session.trades += 1;
    updateStatsUI();

    if (mode === 'demo') {
      simulateDemoTrade(trade);
    } else {
      placeRealTrade(trade);
    }
  }

  // Demo: determine result after duration using latest tick as expiry price.
  function simulateDemoTrade(trade) {
    pendingSimTrades.push(trade);
    log(`(DEMO) Placed simulated ${trade.type} — id ${trade.id}`);

    // check result after duration seconds: use latest tick at that time as expiry price
    setTimeout(() => {
      const expiryPrice = ticks.length ? ticks[ticks.length-1].quote : trade.entryPrice;
      const win = (trade.type === 'CALL') ? (expiryPrice > trade.entryPrice) : (expiryPrice < trade.entryPrice);
      // demo payout assumption: 80% payout -> profit = stake * 0.8 if win
      const payoutMultiplier = 0.8;
      const pnl = win ? Number((trade.stake * payoutMultiplier).toFixed(2)) : -trade.stake;

      trade.status = 'finished';
      trade.pnl = pnl;
      trade.win = win;

      finalizeTrade(trade);
      // remove from pending
      pendingSimTrades = pendingSimTrades.filter(t => t.id !== trade.id);
    }, trade.duration * 1000);
  }

  // Place real trade using Deriv websocket: request proposal then buy
  function placeRealTrade(trade) {
    if (!ws || ws.readyState !== WebSocket.OPEN) {
      log('WebSocket not connected or not ready — cannot place real trade.', 'red');
      return;
    }
    const token = tokenInput.value.trim();
    if (!token) {
      log('No API token provided for Real mode. Provide token and reconnect.', 'red');
      return;
    }

    // prepare proposal request
    const proposalReq = {
      proposal: 1,
      amount: trade.stake,
      basis: 'stake',
      contract_type: trade.type === 'CALL' ? 'CALL' : 'PUT',
      currency: 'USD',
      duration: trade.duration,
      duration_unit: 's',
      symbol: trade.symbol
    };

    // create a small listener for the immediate proposal response + buy confirmation
    const handler = (evt) => {
      try {
        const data = JSON.parse(evt.data);

        // proposal
        if (data.proposal) {
          const proposal = data.proposal;
          // proposal id might be in id or proposal.id; many v3 responses return proposal.id
          const proposalId = proposal.id || proposal.proposal_id || proposal.contract_id || null;
          // In many responses the field to use in buy is `proposal.id` or `proposal.contract_id` or the proposal object itself (v3 is inconsistent in docs). We'll attempt:
          // If proposal has 'id', use buy: { buy: proposal.id }
          log(`Proposal received: payout=${proposal.display_value || proposal.payout || proposal.ask_price || 'n/a'}`);
          if (proposal.id) {
            const buyReq = { buy: proposal.id };
            ws.send(JSON.stringify(buyReq));
            log(`Sent buy for proposal id ${proposal.id}`);
          } else if (proposal.longcode && proposal.ask_price) {
            // fallback: some servers expect buy with proposal object; try sending buy with proposal price
            log('Proposal format unexpected — trying fallback buy (may fail).');
            try { ws.send(JSON.stringify({ buy: proposal })); } catch(e){/*ignore*/ }
          }
        }

        // buy confirmation
        if (data.buy) {
          // buy response might contain transaction id and contract id
          log(`Buy response: ${JSON.stringify(data.buy)}`);
          trade.status = 'placed';
        }

        // contract sold / proposal_open_contract with action 'sold' contains profit
        if (data.proposal_open_contract && data.proposal_open_contract.action === 'sold') {
          const profit = Number(data.proposal_open_contract.profit || 0);
          trade.status = 'finished';
          trade.pnl = profit;
          trade.win = profit > 0;
          finalizeTrade(trade);
        }
      } catch(e) {
        // ignore parse errors
      }
    };

    ws.addEventListener('message', handler);

    // send proposal request
    ws.send(JSON.stringify(proposalReq));
    log(`Sent proposal request for ${trade.type} ${trade.symbol}`);

    // set timeout to remove handler if nothing happens
    setTimeout(() => {
      try { ws.removeEventListener('message', handler); } catch(e){}
      if (trade.status !== 'finished') {
        log('No contract sold message yet — waiting; finalization may be processed later by other messages.', 'small');
      }
    }, 30000);
  }

  // finalize common logic: update session pl, wins/losses, martingale
  function finalizeTrade(trade) {
    const isWin = !!trade.win;
    const pnl = Number(trade.pnl || 0);

    if (isWin) {
      session.wins += 1;
      // In demo we used pnl as profit; in real mode pnl might be raw profit including stake depending on API; user should verify.
      session.pl += pnl;
      currentStake = Number((parseFloat(stakeInput.value) || 1).toFixed(2)); // reset to base stake
      log(`Trade ${trade.id} WIN. P/L: ${pnl.toFixed(2)} — New session P/L: ${session.pl.toFixed(2)}`, 'green');
    } else {
      session.losses += 1;
      session.pl += pnl; // pnl is negative when loss in demo
      // apply martingale
      const mg = parseFloat(martingaleInput.value) || 2.1;
      const next = Number((currentStake * mg).toFixed(2));
      currentStake = Math.max(0.01, next);
      log(`Trade ${trade.id} LOSS. P/L: ${pnl.toFixed(2)} — Next stake: ${currentStake.toFixed(2)}`, 'red');
    }

    updateStatsUI();
  }

  // Connect to Deriv websocket & subscribe ticks
  function connect() {
    if (running) return;
    const symbol = symbolInput.value || 'R_100';
    log(`Connecting to Deriv websocket (app_id=${APP_ID}) and subscribing to ${symbol} ...`);
    ws = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id=' + APP_ID);

    ws.onopen = () => {
      running = true;
      log('WebSocket connected.');
      // if Real mode and token provided, send authorize
      if (modeSel.value === 'real') {
        const token = tokenInput.value.trim();
        if (token) {
          ws.send(JSON.stringify({ authorize: token }));
          log('Sent authorize request.');
        } else {
          log('Real mode selected but no token provided. Real trades will not work.', 'red');
        }
      }
      // subscribe ticks
      ws.send(JSON.stringify({ ticks: symbol, subscribe: 1 }));
      log('Subscribed to ticks for ' + symbol);
    };

    ws.onmessage = (evt) => {
      try {
        const data = JSON.parse(evt.data);
        if (data.tick) {
          const quote = Number(data.tick.quote);
          const epoch = Number(data.tick.epoch);
          pushTick(quote, epoch);
          // evaluate strategy after each tick
          evaluateStrategy();
        }
        if (data.error) {
          log('Error from websocket: ' + JSON.stringify(data.error), 'red');
        }
        // some responses may include proposal_open_contract etc. We capture contract sold messages in placeRealTrade handler too.
      } catch(e) {
        // ignore
      }
    };

    ws.onclose = () => {
      running = false;
      log('WebSocket closed.');
    };

    ws.onerror = (e) => {
      log('WebSocket error: ' + JSON.stringify(e), 'red');
    };
  }

  function stop() {
    if (ws) {
      try { ws.close(); } catch(e){}
      ws = null;
    }
    running = false;
    log('Stopped.');
  }

  // Button bindings
  startBtn.addEventListener('click', () => {
    if (running) { log('Already running.'); return; }
    baseStake = parseFloat(stakeInput.value) || baseStake;
    currentStake = baseStake;
    resetSession(); // optionally start fresh stats each start
    connect();
  });
  stopBtn.addEventListener('click', stop);
  resetBtn.addEventListener('click', resetSession);

  // ensure clean close on page leave
  window.addEventListener('beforeunload', () => {
    if (ws) ws.close();
  });

  // initial UI
  renderTicks();
  updateStatsUI();
  log('Ready — configure settings and press Connect & Start. Demo recommended.');
})();
</script>
</body>
</html>
